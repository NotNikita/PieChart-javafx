package Controllers;

import javafx.collections.ObservableList;
import javafx.scene.chart.PieChart;
import javafx.scene.chart.PieChart.Data;
import javafx.scene.shape.Path;

import java.awt.*;

public class CanvasVersionOfPiChart extends Canvas{
    // A PieChartCanvas can display a pie chart, based on an array
    // of data passed to it in its setData() method.  There can be
    // up to 12 wedges in the pie.

    private int dataCount;     // The number of data values for the chart.
    private ObservableList<PieChart.Data> dataList;
    private Path path;

    private int[] angles;   // An array to hold the angles that divide
    // the wedges.  For convenience, this array
    // is of size dataCt + 1, and it starts with
    // 0 and ends with 360.

    private final static Color[] palette = {  // Colors for the chart.
            Color.red,
            Color.blue,
            Color.green,
            Color.magenta,
            Color.yellow,
            Color.cyan,
            new Color(180,0,0),
            new Color(200,200,255),
            new Color(0,180,0),
            new Color(0,180,180),
            new Color(180,180,0),
            new Color(180,0,180),
    };


    CanvasVersionOfPiChart(ObservableList<PieChart.Data> data,  Path path) {
        // Constructor.  Set the background to be white. Set data list and Path
        dataList = data;
        dataCount = dataList.size(); // it will be length or summ of all elements?
        this.path = path;
        setBackground(Color.white);
    }


    void clearData() {
        // Delete any data and redraw the canvas.  The canvas will
        // be blank except for the message "No data available".
        dataCount = 0;
        dataList = null;
        path = null;
        angles = null;
        repaint();
    }


    void setData(double[] data, int count) {
        // Use data and count for the pie chart.  If data is null or
        // count is <= 0, the current pie chart will be cleared.
        // The count must be in the range 0 to data.length.  If not, it
        // is set to data.length.  All the entries in the array should
        // be positive numbers.  If not, the results will be nonsense.
        // The data needed to draw the pie chart is computed and stored
        // in the angles array.  Note that the number of degrees
        // in the i-th wedge is 360*data[i]/dataSum, where dataSum
        // is the total of all the data values.  The cumulative angles
        // are computed, converted to ints, and stored in angles.
        //          if (count <= 0 || data == null) {
        //              clearData();
        //              return;
        //          }
        //          if (count <= data.length)
        //              dataCount = count;
        //          else
        //              dataCount = data.length;
        angles = new int[dataCount + 1];
        angles[0] = 0;
        angles[dataCount] = 360;
        double dataSum = 0;
        for (PieChart.Data node: dataList) {
            dataSum += node.getPieValue();
        }
        double sum = 0;
        for (int i = 1; i < dataCount; i++) {
            sum += dataList.get(i-1).getPieValue();
            angles[i] = (int)(360*sum/dataSum + 0.5);
        }
        repaint();
    }


    public void paint(Graphics g) {

        // Draw the pie chart, if there is data available.
        // If not, just show the message "No data available".

        if (dataCount == 0) {
            g.drawString("No data available.", 10,15);
            return;
        }

          /* The pie chart occupies a circle centered on the canvas.
             Compute some parameters for drawing it.
          */

        int centerX = getSize().width / 2;   // Center point of circle.
        int centerY = getSize().height / 2;

        int radius;   // Radius of the circle.  This is 20 pixels less
        // than the smaller of half the width and
        // half the height.

        if (centerX < centerY)
            radius = centerX - 20;
        else
            radius = centerY - 20;

        int top = centerY - radius;    // Top edge of square
        //    that contains the circle.
        int left = centerX - radius;   // Left edge of square
        //    that contains the circle.
        int diameter = 2*radius;       // Length of a side of the square.


        for (int i = 0; i < dataCount; i++) {
            // Draw the next wedge.  The start angle for the wedge
            // is angles[i].  The ending angle is angles[i+1}, so
            // the number of degrees in the wedge is
            // angles[i+1] - angles[i].
            g.setColor( palette[i] );
            g.fillArc( left, top, diameter, diameter,
                    angles[i], angles[i+1] - angles[i] ) ;
        }

    }

}
